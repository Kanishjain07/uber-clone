// WebSocket Integration JavaScript
class SocketManager {
    constructor() {
        this.socket = null;
        this.isConnected = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 1000;
        this.heartbeatInterval = null;
        this.messageQueue = [];
        this.eventListeners = new Map();
        this.init();
    }

    init() {
        this.setupEventListeners();
        this.connect();
    }

    setupEventListeners() {
        // Listen for authentication changes
        if (window.authManager) {
            // This would typically be done through a proper event system
            // For now, we'll check periodically
            setInterval(() => {
                this.checkAuthAndReconnect();
            }, 10000);
        }

        // Listen for page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                this.pauseHeartbeat();
            } else {
                this.resumeHeartbeat();
            }
        });

        // Listen for online/offline events
        window.addEventListener('online', () => {
            this.handleOnline();
        });

        window.addEventListener('offline', () => {
            this.handleOffline();
        });
    }

    connect() {
        try {
            // Get WebSocket URL from environment or use default
            const wsUrl = this.getWebSocketURL();
            
            // Create WebSocket connection
            this.socket = new WebSocket(wsUrl);
            
            // Setup event handlers
            this.socket.onopen = () => this.handleConnectionOpen();
            this.socket.onmessage = (event) => this.handleMessage(event);
            this.socket.onclose = (event) => this.handleConnectionClose(event);
            this.socket.onerror = (error) => this.handleConnectionError(error);
            
        } catch (error) {
            console.error('Failed to create WebSocket connection:', error);
            this.scheduleReconnect();
        }
    }

    getWebSocketURL() {
        // Use localhost for development
        console.log('Using localhost WebSocket URL');
        return 'ws://localhost:9000';
    }

    handleConnectionOpen() {
        console.log('WebSocket connection established');
        this.isConnected = true;
        this.reconnectAttempts = 0;
        this.startHeartbeat();
        this.flushMessageQueue();
        this.authenticate();
        
        // Emit connection event
        this.emit('connected');
    }

    handleMessage(event) {
        try {
            const data = JSON.parse(event.data);
            this.processMessage(data);
        } catch (error) {
            console.error('Error parsing WebSocket message:', error);
        }
    }

    processMessage(data) {
        const { type, payload, timestamp } = data;
        
        // Handle different message types
        switch (type) {
            case 'ride_update':
                this.handleRideUpdate(payload);
                break;
            case 'driver_location':
                this.handleDriverLocation(payload);
                break;
            case 'ride_request':
                this.handleRideRequest(payload);
                break;
            case 'notification':
                this.handleNotification(payload);
                break;
            case 'pong':
                this.handlePong();
                break;
            default:
                console.log('Unknown message type:', type, payload);
        }

        // Emit message event
        this.emit('message', { type, payload, timestamp });
    }

    handleRideUpdate(payload) {
        const { rideId, status, driverInfo, eta } = payload;
        
        // Update ride status if ride manager exists
        if (window.rideManager) {
            window.rideManager.updateRideStatus(rideId, status, driverInfo, eta);
        }

        // Show notification
        this.showNotification(`Ride ${status}: ${eta || ''}`, 'info');
    }

    handleDriverLocation(payload) {
        const { driverId, location, rideId } = payload;
        
        // Update driver location on map if map manager exists
        if (window.mapManager) {
            window.mapManager.updateDriverLocation(driverId, location, rideId);
        }
    }

    handleRideRequest(payload) {
        const { requestId, pickup, destination, distance, estimatedFare } = payload;
        
        // Show ride request to driver if driver manager exists
        if (window.driverManager && window.driverManager.isDriverOnline()) {
            window.driverManager.receiveRideRequest({
                id: requestId,
                pickup,
                destination,
                distance,
                estimatedFare,
                timestamp: new Date().toISOString()
            });
        }
    }

    handleNotification(payload) {
        const { message, type, title } = payload;
        
        // Show notification
        this.showNotification(message, type, title);
    }

    handlePong() {
        // Reset heartbeat timeout
        this.lastPongTime = Date.now();
    }

    handleConnectionClose(event) {
        console.log('WebSocket connection closed:', event.code, event.reason);
        this.isConnected = false;
        this.stopHeartbeat();
        
        // Emit disconnection event
        this.emit('disconnected', { code: event.code, reason: event.reason });
        
        // Attempt to reconnect if not a clean close
        if (event.code !== 1000) {
            this.scheduleReconnect();
        }
    }

    handleConnectionError(error) {
        console.error('WebSocket connection error:', error);
        this.isConnected = false;
    }

    scheduleReconnect() {
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            console.error('Max reconnection attempts reached');
            this.emit('reconnect_failed');
            return;
        }

        this.reconnectAttempts++;
        const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
        
        console.log(`Scheduling reconnection attempt ${this.reconnectAttempts} in ${delay}ms`);
        
        setTimeout(() => {
            this.connect();
        }, delay);
    }

    checkAuthAndReconnect() {
        // Check if user is authenticated and reconnect if needed
        if (window.authManager && window.authManager.isUserAuthenticated() && !this.isConnected) {
            console.log('User authenticated but socket disconnected, attempting reconnect');
            this.connect();
        }
    }

    authenticate() {
        // Send authentication message if user is logged in
        if (window.authManager && window.authManager.isUserAuthenticated()) {
            const user = window.authManager.getCurrentUser();
            this.send('authenticate', {
                userId: user.id,
                userType: user.userType,
                token: localStorage.getItem('authToken')
            });
        }
    }

    startHeartbeat() {
        this.heartbeatInterval = setInterval(() => {
            this.sendHeartbeat();
        }, 30000); // Send heartbeat every 30 seconds
    }

    stopHeartbeat() {
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
        }
    }

    pauseHeartbeat() {
        // Pause heartbeat when page is not visible
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
        }
    }

    resumeHeartbeat() {
        // Resume heartbeat when page becomes visible
        if (this.isConnected && !this.heartbeatInterval) {
            this.startHeartbeat();
        }
    }

    sendHeartbeat() {
        this.send('ping', { timestamp: Date.now() });
        
        // Set timeout for pong response
        setTimeout(() => {
            if (this.lastPongTime && (Date.now() - this.lastPongTime) > 60000) {
                console.warn('No pong received, connection may be stale');
                this.reconnect();
            }
        }, 5000);
    }

    send(type, payload) {
        const message = {
            type,
            payload,
            timestamp: Date.now()
        };

        if (this.isConnected && this.socket && this.socket.readyState === WebSocket.OPEN) {
            try {
                this.socket.send(JSON.stringify(message));
            } catch (error) {
                console.error('Error sending message:', error);
                this.queueMessage(message);
            }
        } else {
            this.queueMessage(message);
        }
    }

    queueMessage(message) {
        this.messageQueue.push(message);
        
        // Limit queue size
        if (this.messageQueue.length > 100) {
            this.messageQueue.shift();
        }
    }

    flushMessageQueue() {
        while (this.messageQueue.length > 0) {
            const message = this.messageQueue.shift();
            try {
                this.socket.send(JSON.stringify(message));
            } catch (error) {
                console.error('Error flushing queued message:', error);
                // Re-queue failed messages
                this.messageQueue.unshift(message);
                break;
            }
        }
    }

    // Event system
    on(event, callback) {
        if (!this.eventListeners.has(event)) {
            this.eventListeners.set(event, []);
        }
        this.eventListeners.get(event).push(callback);
    }

    off(event, callback) {
        if (this.eventListeners.has(event)) {
            const callbacks = this.eventListeners.get(event);
            const index = callbacks.indexOf(callback);
            if (index > -1) {
                callbacks.splice(index, 1);
            }
        }
    }

    emit(event, data) {
        if (this.eventListeners.has(event)) {
            this.eventListeners.get(event).forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error('Error in event callback:', error);
                }
            });
        }
    }

    // Public methods for external use
    sendRideRequest(rideDetails) {
        this.send('ride_request', rideDetails);
    }

    updateDriverLocation(location) {
        this.send('driver_location', location);
    }

    acceptRide(rideId) {
        this.send('accept_ride', { rideId });
    }

    declineRide(rideId) {
        this.send('decline_ride', { rideId });
    }

    startRide(rideId) {
        this.send('start_ride', { rideId });
    }

    completeRide(rideId) {
        this.send('complete_ride', { rideId });
    }

    cancelRide(rideId, reason) {
        this.send('cancel_ride', { rideId, reason });
    }

    // Connection management
    disconnect() {
        if (this.socket) {
            this.socket.close(1000, 'User initiated disconnect');
        }
    }

    reconnect() {
        if (this.socket) {
            this.socket.close();
        }
        this.connect();
    }

    // Utility methods
    isConnected() {
        return this.isConnected;
    }

    getConnectionStatus() {
        if (!this.socket) return 'disconnected';
        
        switch (this.socket.readyState) {
            case WebSocket.CONNECTING:
                return 'connecting';
            case WebSocket.OPEN:
                return 'connected';
            case WebSocket.CLOSING:
                return 'closing';
            case WebSocket.CLOSED:
                return 'closed';
            default:
                return 'unknown';
        }
    }

    showNotification(message, type = 'info', title = '') {
        // Use app notification if available
        if (window.app && window.app.showNotification) {
            window.app.showNotification(message, type);
        } else {
            // Fallback notification
            console.log(`${type.toUpperCase()}: ${title ? title + ' - ' : ''}${message}`);
        }
    }

    // Handle online/offline events
    handleOnline() {
        console.log('Network connection restored');
        if (!this.isConnected) {
            this.connect();
        }
    }

    handleOffline() {
        console.log('Network connection lost');
        this.isConnected = false;
        this.stopHeartbeat();
    }

    // Cleanup
    destroy() {
        this.disconnect();
        this.eventListeners.clear();
        this.messageQueue = [];
        
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
        }
    }
}

// Initialize socket manager when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.socketManager = new SocketManager();
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    if (window.socketManager) {
        window.socketManager.destroy();
    }
});

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = SocketManager;
}
